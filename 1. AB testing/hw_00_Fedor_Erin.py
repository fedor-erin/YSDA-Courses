"""Домашнее задание #0.

Вам нужно написать две функции для нахождения точечной оценки и доверительного интервала параметра p геометрического распределения Geom(p).
На вход функциям будет подаваться выборка из геометрического распределения.
Значения выборки - кол-во неуспешных испытаний до первого успешного испытания.
Пример:
1 -> X=0
01 -> X=1
0001 -> X=3


Для успешной сдачи задания нужно:

1. Реализовать код функций.
2. Переименовать файл, заменив в нём <firstname> и <lastname>.
3. Отправить py-файл на проверку.

Для проверки правильности реализации функций можно запустить py-файл командой в терминале python3 <file_name>.py. Должны отобразиться точечные оценки и доверительные интервалы, построенные для различных размеров выборки. Проверьте, что при увеличении размера выборки оценка параметра становится точнее, а доверительные интервалы более узкими.

Баллы: за правильную реализацию каждой функции даётся 5 баллов.
"""

import numpy as np
from scipy import stats


def get_p_estimation(data: np.array) -> float:
    """Находит ОМП параметра p геометрического р-ния."""
    # теоретический вывод
    # (lnL)' = (ln(Πp(1-p)^x_i))' = (n*lnp + ln(1-p)*Σx_i)' = 0  => 
    # n/p + Σx_i/(p-1) = 0  =>  
    # p = 1/(Σx_i/n + 1) = 1/(x̄ + 1)
    return 1. / (data.mean() + 1)


def get_ci(data: np.array, alpha: float=0.05) -> tuple:
    """Находит ДИ для параметра p геометрического р-ния."""
    # теоретические значения Geom(p): EX = (1-p)/p, D = (1-p)/p^2
    # по свойству инвариантности ОМП: ṕ - ОМП p => σ(ṕ) - ОМП для σ(p)
    # по ЦПТ: √n*(X̅-EX)/σ ~ N(0,1), где σ=σ(ṕ), z соответствует α/2  =>
    # -zσ/√n < X̅+1-1/p < zσ/√n  =>
    # 1/(zσ/√n + 1/ṕ) < p < 1/(-zσ/√n + 1/ṕ)
    n = len(data)
    p_est = get_p_estimation(data)
    variance_est = (1 - p_est) / p_est**2
    z = stats.norm.ppf(1 - alpha / 2)
    return (1/(1/p_est + z * (variance_est / n)**0.5), 
            1/(1/p_est - z * (variance_est / n)**0.5))


if __name__ == "__main__":
    np.random.seed(71)

    print(f'{"size": ^7}|{"p": ^7}|{"p_est": ^7}|{"CI": ^15}')
    print(f'{"":-^40}')
    sizes = np.logspace(1, 5, 10).astype(int)
    for size in sizes:
        p = np.random.rand()
        data = np.random.geometric(p, size) - 1
        p_estimation = get_p_estimation(data)
        ci = get_ci(data)
        ci_print = f'({ci[0]:0.3f}, {ci[1]:0.3f})'
        print(f'{size: >7}|{round(p, 3): ^7}|{round(p_estimation, 3): ^7}|{ci_print: ^16}')